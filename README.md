# test-shell-genid

**`genid.sh`** defines a shell function `genid` which generates unique, sequential, zero-padded serial numbers in a single-host, multi-process-safe way.
- The `genid` implementation achieves correct behavior in concurrency by keeping track of the last used ID number in a file, called `.counter`. Access to the `.counter` file is synchronized using the `flock` utility, which requires a process to obtain an exclusive lock on the file before reading and incrementing its content.
- This solution is performant because each process holds the file lock for a minimal amount of time.
- The `genid` function is also robust to corruptions of the `.counter` file, since it checks that the contents are a valid number before using it.
- File locking for synchronization is simple,  reliable for single-host multi-processing at the level we are designing for (tens of processes, thousands of IDs), but may not scale well to extreme read/write loads.

**`testid.sh`** defines tests to verify that `genid` performs correctly and measures its performance.
- The test suite includes four types of tests:
    - `single_proc_single_id`: basic initial test for correctly generating one ID number
    - `single_proc_many_id`: tests that multiple ID numbers are correctly generated by one process (no multi-processing yet), i.e. 1000 ID numbers
    - `many_proc_single_id`: tests that multiple processes correctly generate one ID number each, i.e. 50 processes
    - `many_proc_many_id`: tests that multiple processes each correctly generate multiple ID numbers, i.e. 50 processes generating 100 ID numbers each
- The tests log information about each test that was ran (e.g. total tests passed, diffs between expected and output for failed tests)
- The test implementation uses helper functions(`test_proc_genid`, `verify_genid_output`, `get_time`) to minimize code repetition and be flexible to future modification.
- The tests also measure how long each test took to run, and calculates the throughput rate of IDs/ms.
- The `genid` and `testid` implementations are portable across Linux and MacOS platforms. The output of a sample test run on Parallel Works ACTIVATE is shown below:
```
=== testid.sh ===
Running test: single_proc_single_id
    [PASS]
    Generated 1 IDs in 8 ms (125 IDs/sec)
Running test: single_proc_many_id
    [PASS]
    Generated 1000 IDs in 2555 ms (391 IDs/sec)
Running test: many_proc_single_id
    [PASS]
    Generated 50 IDs in 81 ms (617 IDs/sec)
Running test: many_proc_many_id
    [PASS]
    Generated 5000 IDs in 7273 ms (687 IDs/sec)
Running test: many_proc_many_id
    [PASS]
    Generated 5000 IDs in 7286 ms (686 IDs/sec)
Running test: many_proc_many_id
    [PASS]
    Generated 5000 IDs in 7393 ms (676 IDs/sec)
Running test: many_proc_many_id
    [PASS]
    Generated 5000 IDs in 7609 ms (657 IDs/sec)
Running test: many_proc_many_id
    [PASS]
    Generated 5000 IDs in 7562 ms (661 IDs/sec)
=== Test Summary ===
Tests Passed: 8
Tests Failed: 0
(8/8)
```
- The output of a sample test run locally on my computer (Apple M1) is shown below:
```
=== testid.sh ===
Running test: single_proc_single_id
    [PASS]
    Generated 1 IDs in 19 ms (52 IDs/sec)
Running test: single_proc_many_id
    [PASS]
    Generated 1000 IDs in 1486 ms (672 IDs/sec)
Running test: many_proc_single_id
    [PASS]
    Generated 50 IDs in 78 ms (641 IDs/sec)
Running test: many_proc_many_id
    [PASS]
    Generated 5000 IDs in 3757 ms (1330 IDs/sec)
Running test: many_proc_many_id
    [PASS]
    Generated 5000 IDs in 3707 ms (1348 IDs/sec)
Running test: many_proc_many_id
    [PASS]
    Generated 5000 IDs in 3768 ms (1326 IDs/sec)
Running test: many_proc_many_id
    [PASS]
    Generated 5000 IDs in 3703 ms (1350 IDs/sec)
Running test: many_proc_many_id
    [PASS]
    Generated 5000 IDs in 3948 ms (1266 IDs/sec)
=== Test Summary ===
Tests Passed: 8
Tests Failed: 0
(8/8)
```